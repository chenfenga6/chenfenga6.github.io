<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MybatisGenerator生成Example的使用方法</title>
    <link href="/2020/06/17/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90-20200617-MybatisGenerator%E7%94%9F%E6%88%90Example%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/17/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90-20200617-MybatisGenerator%E7%94%9F%E6%88%90Example%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上篇介绍了SpringBoot整合generator插件的过程以及一些坑。<br><strong>所以本篇文章主要介绍生成出来的实体类、Example、mapper如何进行使用，以及小麻袋在使用过程中遇到的一些问题。</strong></p></blockquote><h2 id="1-Generator插件生成Mapper和Example文件介绍"><a href="#1-Generator插件生成Mapper和Example文件介绍" class="headerlink" title="1.Generator插件生成Mapper和Example文件介绍"></a>1.Generator插件生成Mapper和Example文件介绍</h2><h3 id="1-1-Mapper文件"><a href="#1-1-Mapper文件" class="headerlink" title="1-1.Mapper文件"></a>1-1.Mapper文件</h3><p>mapper层接口中主要提供一些关于主键和通过Example类作为参数的方法，如下：</p><table><thead><tr><th align="left">方法</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">int countByExample(UserExample example) thorws SQLException</td><td align="left">按条件计数</td></tr><tr><td align="left">int deleteByPrimaryKey(Integer id) thorws SQLException</td><td align="left">按主键删除</td></tr><tr><td align="left">int deleteByExample(UserExample example) thorws SQLException</td><td align="left">按条件查询</td></tr><tr><td align="left">String/Integer insert(User record) thorws SQLException</td><td align="left">插入数据（返回值为ID）</td></tr><tr><td align="left">T selectByPrimaryKey(Integer id) thorws SQLException</td><td align="left">按主键查询</td></tr><tr><td align="left">ListselectByExample(UserExample example) thorws SQLException</td><td align="left">按条件查询</td></tr><tr><td align="left">ListselectByExampleWithBLOGs(UserExample example) thorws SQLException</td><td align="left">按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。</td></tr><tr><td align="left">int updateByPrimaryKey(User record) thorws SQLException</td><td align="left">按主键更新</td></tr><tr><td align="left">int updateByPrimaryKeySelective(User record) thorws SQLException</td><td align="left">按主键更新值不为null的字段</td></tr><tr><td align="left">int updateByExample(User record, UserExample example) thorws SQLException</td><td align="left">按条件更新</td></tr><tr><td align="left">int updateByExampleSelective(User record, UserExample example) thorws SQLException</td><td align="left">按条件更新值不为null的字段</td></tr></tbody></table><h3 id="1-2-Example文件"><a href="#1-2-Example文件" class="headerlink" title="1-2.Example文件"></a>1-2.Example文件</h3><p>mybatis-generator （逆向工程）会生成实例以及实例对应的Example，其主要作用就是能够自己组装sql语句中where后面的条件。<br>xxxExample example = new xxxExample();<br>Criteria criteria = new Example().createCriteria();</p><table><thead><tr><th align="left">方法</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">example.setOrderByClause(“字段名 ASC”);</td><td align="left">添加升序排列条件，DESC为降序</td></tr><tr><td align="left">example.setDistinct(false)</td><td align="left">去除重复，boolean型，true为选择不重复的记录。</td></tr><tr><td align="left">criteria.andXxxIsNull</td><td align="left">添加字段xxx为null的条件</td></tr><tr><td align="left">criteria.andXxxIsNotNull</td><td align="left">添加字段xxx不为null的条件</td></tr><tr><td align="left">criteria.andXxxEqualTo(value)</td><td align="left">添加xxx字段等于value条件</td></tr><tr><td align="left">criteria.andXxxNotEqualTo(value)</td><td align="left">添加xxx字段不等于value条件</td></tr><tr><td align="left">criteria.andXxxGreaterThan(value)</td><td align="left">添加xxx字段大于value条件</td></tr><tr><td align="left">criteria.andXxxGreaterThanOrEqualTo(value)</td><td align="left">添加xxx字段大于等于value条件</td></tr><tr><td align="left">criteria.andXxxLessThan(value)</td><td align="left">添加xxx字段小于value条件</td></tr><tr><td align="left">criteria.andXxxLessThanOrEqualTo(value)</td><td align="left">添加xxx字段小于等于value条件</td></tr><tr><td align="left">criteria.andXxxIn(List&lt;？&gt;)</td><td align="left">添加xxx字段值在List&lt;？&gt;条件</td></tr><tr><td align="left">criteria.andXxxNotIn(List&lt;？&gt;)</td><td align="left">添加xxx字段值不在List&lt;？&gt;条件</td></tr><tr><td align="left">criteria.andXxxLike(“%”+value+”%”)</td><td align="left">添加xxx字段值为value的模糊查询条件</td></tr><tr><td align="left">criteria.andXxxNotLike(“%”+value+”%”)</td><td align="left">添加xxx字段值不为value的模糊查询条件</td></tr><tr><td align="left">criteria.andXxxBetween(value1,value2)</td><td align="left">添加xxx字段值在value1和value2之间条件</td></tr><tr><td align="left">criteria.andXxxNotBetween(value1,value2)</td><td align="left">添加xxx字段值不在value1和value2之间条</td></tr></tbody></table><h2 id="2-使用中遇到的问题"><a href="#2-使用中遇到的问题" class="headerlink" title="2.使用中遇到的问题"></a>2.使用中遇到的问题</h2><h3 id="2-1-or-和createcriteria的区别？"><a href="#2-1-or-和createcriteria的区别？" class="headerlink" title="2-1.or()和createcriteria的区别？"></a>2-1.or()和createcriteria的区别？</h3><blockquote><p>createcriteria，当没有规则时，则加入到现有规则，但有规则时，不再加入到现有规则，只是返回创建的规则，如源码所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Criteria <span class="hljs-title function_">createCriteria</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Criteria</span> <span class="hljs-variable">criteria</span> <span class="hljs-operator">=</span> createCriteriaInternal();<br>        <span class="hljs-keyword">if</span> (oredCriteria.size() == <span class="hljs-number">0</span>) &#123;<br>            oredCriteria.add(criteria);<br>        &#125;<br>        <span class="hljs-keyword">return</span> criteria;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>or，创建的规则，加入到规则集中，并且是or的关系，如源码所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Criteria <span class="hljs-title function_">or</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Criteria</span> <span class="hljs-variable">criteria</span> <span class="hljs-operator">=</span> createCriteriaInternal();<br>    oredCriteria.add(criteria);<br>    <span class="hljs-keyword">return</span> criteria;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-selectByExample-和-selectByExampleWithBLOGs-的区别？"><a href="#2-2-selectByExample-和-selectByExampleWithBLOGs-的区别？" class="headerlink" title="2-2.selectByExample() 和 selectByExampleWithBLOGs()的区别？"></a>2-2.selectByExample() 和 selectByExampleWithBLOGs()的区别？</h3><blockquote><p>selectByExampleWithBLOGs这个方法是我在开发过程中遇到问题后，才发现有这样一个方法。<br>当时是因为我表中有个字段类型为<strong>text</strong>长字段，使用selectByExample查询时，基本字段都能查找到，除了这个text类型的字段一直为空。</p></blockquote><p>1.两个方法的返回的resultMap不同<br>selectByExample  方法返回：BaseResultMap<br>selectByExampleWithBLOBs  方法返回：ResultMapWithBLOBs<br>ResultMapWithBLOBs 定义时，继承了BaseResultMap，并且拥有自己特殊的字段，该字段通常是<strong>longvarchar类型</strong></p><p>2.使用场景不同<br>若<strong>检索大字段</strong>时，则需要使用selectByExampleWithBLOBs  ，一般情况则使用selectByExample  即可。</p><h3 id="2-3-Mybatis逆向工程如何多表查询？"><a href="#2-3-Mybatis逆向工程如何多表查询？" class="headerlink" title="2-3.Mybatis逆向工程如何多表查询？"></a>2-3.Mybatis逆向工程如何多表查询？</h3><p>mybatisGenerator生成的Example都是用于单表操作的，如果需要进行多表查询，就和mybatis进行多表查询一样，在xml中自己写sql。</p>]]></content>
    
    
    <categories>
      
      <category>项目组件集成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot2.x整合MybatisGenerator</title>
    <link href="/2020/06/09/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90-20200609-SpringBoot2.x%E6%95%B4%E5%90%88Mybatis-Generator/"/>
    <url>/2020/06/09/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90-20200609-SpringBoot2.x%E6%95%B4%E5%90%88Mybatis-Generator/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本篇不对mybatis-generator进行简介，直接讲述SpringBoot集成过程。<br>使用的SpringBoot版本是2.2.2.RELEASE</strong></p></blockquote><h2 id="1-整合mybatis-generator插件"><a href="#1-整合mybatis-generator插件" class="headerlink" title="1.整合mybatis-generator插件"></a>1.整合mybatis-generator插件</h2><h3 id="1-1-在pom-xml—bulid—plugins-标签内导入插件依赖"><a href="#1-1-在pom-xml—bulid—plugins-标签内导入插件依赖" class="headerlink" title="1.1 在pom.xml—bulid—plugins 标签内导入插件依赖"></a>1.1 在pom.xml—bulid—plugins 标签内导入插件依赖</h3><blockquote><p>依赖中使用的版本分别是：<br>&lt;mybatisgenerator.version&gt;<strong>1.3.7</strong>&lt;/mybatisgenerator.version&gt;<br>        &lt;mysql.version&gt;<strong>5.1.47</strong>&lt;/mysql.version&gt;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;plugin&gt;<br>   &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;<br>   &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;<br>   &lt;version&gt;$&#123;mybatisgenerator.version&#125;&lt;/version&gt;<br>   &lt;!--添加一个mysql的依赖,防止等会找不到driverClass--&gt;<br>   &lt;dependencies&gt;<br>   &lt;dependency&gt;<br>   &lt;groupId&gt;mysql&lt;/groupId&gt;<br>   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>   &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;<br>   &lt;/dependency&gt;<br>   &lt;/dependencies&gt;<br>    &lt;configuration&gt;<br>    &lt;!--需要定位到自己项目中generator-config.xml的位置--&gt;<br>    &lt;configurationFile&gt;src/main/resources/mybatis-generator/generator-config.xml&lt;/configurationFile&gt;<br>    &lt;!--是否覆盖此，处特别注意,如果不加这个设置会导致每次运行都会在原目录再次创建--&gt;<br>    &lt;overwrite&gt;<span class="hljs-literal">true</span>&lt;/overwrite&gt;<br>    &lt;/configuration&gt;<br>&lt;/plugin&gt;<br></code></pre></div></td></tr></table></figure><h3 id="1-2添加配置文件generator-config-xml"><a href="#1-2添加配置文件generator-config-xml" class="headerlink" title="1.2添加配置文件generator-config.xml"></a>1.2添加配置文件generator-config.xml</h3><blockquote><p>在插件依赖中<strong>configurationFile</strong>标签内中的位置，建立generator-config.xml文件<br>内容如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!<span class="hljs-variable constant_">DOCTYPE</span> generatorConfiguration<br>        <span class="hljs-variable constant_">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br>        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--执行generator插件生成文件的命令： call mvn mybatis-generator:generate -e --&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 引入配置文件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;application.yml&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MySQLTables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span> <span class="hljs-attr">defaultModelType</span>=<span class="hljs-string">&quot;flat&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--        配置生成pojo的toString()方法插件--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 公共设置 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 是否取消自动生成时的注释 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 是否取消在注释中加上时间 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 链接数据库的配置 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;org.gjt.mm.mysql.Driver&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost/tb2019&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 关于生成实体类的设置 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- targetPackage 生成代码的目标目录 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- targetProject 目录所属位置 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;cn.org.nercita.user.entity&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 在targetPackge的基础上根据schema再生成一层package 默认flase --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 是否在get方法中 对String类型的字段做空的判断 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 是否生成一个包含所有字段的构造器 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;constructorBased&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 是否创建一个不可变类--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;immutable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--关于生成映射文件的设置--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--同上--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--关于生成mapper层的设置--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;mapper&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;cn.org.nercita.user.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--同上--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--需要生成的代码对应的表名</span></span><br><span class="hljs-comment"><span class="language-xml">            tableName 对应表名</span></span><br><span class="hljs-comment"><span class="language-xml">            domainObjectName 实体类名称</span></span><br><span class="hljs-comment"><span class="language-xml">             如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate</span></span><br><span class="hljs-comment"><span class="language-xml">              &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">        --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;indent&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Indent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>要注意的是要进行<strong>修改你本地的数据库配置</strong>，实体类、mapper层、映射文件的<strong>包名路径</strong>。最后的table标签中tableName对应你本地数据库中的表名，domainObjectName对应生成的实体类文件名（不写默认大驼峰命名），如果有<strong>多个表</strong>则<strong>多</strong>粘贴几个<strong>table标签</strong>即可一次运行全部生成。</p><h3 id="1-3配置、运行genator"><a href="#1-3配置、运行genator" class="headerlink" title="1.3配置、运行genator"></a>1.3配置、运行genator</h3><p><img src="https://img-blog.csdnimg.cn/20200609104619179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/2020060910471354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200609104754445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70" alt="命名"></p><blockquote><p>此图中<br><strong>Name</strong>就是取一个名字<br><strong>Working directory</strong>选择此项目路径<br><strong>command line</strong> 需要输入命令：<strong>mybatis-generator:generate -e</strong><br>（ 如果导包成功的话，输入命令mybatis时，会自动弹出后面的提示哦）<br>之后点击apply，点击绿色运行就能生成啦</p></blockquote><h3 id="1-4遇到的坑"><a href="#1-4遇到的坑" class="headerlink" title="1.4遇到的坑"></a>1.4遇到的坑</h3><p><strong>1.最后运行genator时报找不到mysql驱动的问题</strong><br>解决办法：在步骤1.1中导入依赖的过程时，添加一个mysql的依赖。<br>如果加了依赖还是运行报错找不到驱动，就试着步骤1.2中，手动输入数据库相关的配置。<br>（此处原本我是引用了配置文件，从配置文件中获取变量的方式来配置数据库的，但发现变量获取不到，从而导致了找不到mysql的驱动，就试着手动填写就能够成功运行啦。）</p>]]></content>
    
    
    <categories>
      
      <category>项目组件集成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MQTT在消息到达回调函数中处理数据库操作触发断线问题解决方法</title>
    <link href="/2019/07/06/%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95-20190706-MQTT%E5%9C%A8%E6%B6%88%E6%81%AF%E5%88%B0%E8%BE%BE%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%A7%A6%E5%8F%91%E6%96%AD%E7%BA%BF%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2019/07/06/%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95-20190706-MQTT%E5%9C%A8%E6%B6%88%E6%81%AF%E5%88%B0%E8%BE%BE%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%A7%A6%E5%8F%91%E6%96%AD%E7%BA%BF%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="问题原因（个人理解）"><a href="#问题原因（个人理解）" class="headerlink" title="问题原因（个人理解）"></a>问题原因（个人理解）</h1><p>在MQTT消息到达回调函数中 不能有一些<strong>异常的操作</strong>否则都会触掉线<br>比如：我在回调函数中，获取到的数据类型是<strong>Float类型</strong>，我用<strong>Integer类型变量</strong>进行比较的时候，它就会触发掉线操作（我也挺纳闷的，不过强转成Float类型后就不再有问题了）。</p><p><strong>正题</strong>： 为什么做到对Dao层的操作就掉线了？？？</p><p><strong>首先我在PushCallback回调类中，注入了Dao层的操作</strong><br><img src="https://img-blog.csdnimg.cn/2019072416420553.png"><br><strong>然后在messageArrived中调用：（我取了个固定的id）</strong><br><img src="https://img-blog.csdnimg.cn/20190724164356876.png"></p><p>运行以后，就掉线了，报错如下：<br><img src="https://img-blog.csdnimg.cn/2019072416403816.png"><br>报了<strong>空指针</strong>的问题？？这就说明我注入的UserDao userDao ,并<strong>没有真正的注入</strong>进来，调用的话引用不到为Null ，所以代码具有异常 导致掉线（个人理解）。</p><h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><p><strong>我直接把自己项目中使用方法搬过来</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解决了在PushCallbcak中无法对数据库操作的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveData</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> TerminalDao terminalDao;<span class="hljs-comment">//把我们要用到的Dao层操作注入到这个类中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SaveData saveData;  <span class="hljs-comment">//必须要重写一下！！</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        saveData = <span class="hljs-built_in">this</span>;<br>        saveData.terminalDao = <span class="hljs-built_in">this</span>.terminalDao;<span class="hljs-comment">//改成你们对应的Dao层</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Terminal <span class="hljs-title function_">selectTerminal</span><span class="hljs-params">(<span class="hljs-type">int</span> tid)</span>&#123;<span class="hljs-comment">//把Dao层的操作封装成一个方法</span><br>        <span class="hljs-keyword">return</span> terminalDao.Select_byTid(tid);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>这个类直接添加在PushCallback中即可</strong><br><strong>给你们看一下我的PushCallback结构：</strong><br><img src="https://img-blog.csdnimg.cn/20190724170627871.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70"><br><strong>接下来，我们就可以在messageArrived中调用我刚刚写的方法来对数据库进行操</strong><br><img src="https://img-blog.csdnimg.cn/20190724170904184.png"><br>因为我做的是查询操作，所以new 了一个Terminal对象来接收。<br>最主要的一句就是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">SaveData.saveData.selectTerminal(Integer.parseInt(str.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>]))<br></code></pre></div></td></tr></table></figure><p><strong>第一个：SaveData 是我们刚刚定义的类名<br>第二个：saveDate 是我们在SaveData中重申的变量<br>第三个：selectTerminal就是 自己定义的方法名了</strong></p><p><strong>接下来再去操作数据库的时候，就不会有问题啦<br>问题解决啦！</strong></p>]]></content>
    
    
    <categories>
      
      <category>实战问题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vm虚拟机遇到上不了网问题解决方法</title>
    <link href="/2019/03/30/%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95-20190330-Vm%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%81%87%E5%88%B0%E4%B8%8A%E4%B8%8D%E4%BA%86%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2019/03/30/%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95-20190330-Vm%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%81%87%E5%88%B0%E4%B8%8A%E4%B8%8D%E4%BA%86%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机的网络链接方式"><a href="#虚拟机的网络链接方式" class="headerlink" title="虚拟机的网络链接方式"></a>虚拟机的网络链接方式</h1><p>首先我们先来了解一下VMware网络连接的的三种配置，分别是<strong>Bridge 模式</strong>、<strong>NAT 模式</strong>、<strong>Host Only 模式</strong>。</p><h2 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h2><p>VMware桥接模式，也就是将虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器直接访问到外部网络。简而言之，这就好像在局域网中添加了一台新的、独立的计算机一样。因此，虚拟机也会占用局域网中的一个IP地址，并且可以和其他终端进行相互访问。桥接模式网络连接支持有线和无线主机网络适配器。如果你想把虚拟机当做一台完全独立的计算机看待，并且允许它和其他终端一样的进行网络通信，那么桥接模式通常是虚拟机访问网络的最简单途径（<strong>相当于桥接模式下的虚拟机拥有一个与主机不同的IP</strong>）。</p><h2 id="NAT-模式"><a href="#NAT-模式" class="headerlink" title="NAT 模式"></a>NAT 模式</h2><p>NAT，是Network Address Translation的缩写，意即网络地址转换。NAT模式也是VMware创建虚拟机的默认网络连接模式。使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据”包裹”，都会交由NAT网络适配器加上”特殊标记”并以主机的名义转发出去，外部网络返回的响应数据”包裹”，也是先由主机接收，然后交由NAT网络适配器根据”特殊标记”进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下，外部网络终端也无法访问到虚拟机（<strong>相当于NAT模式下的虚拟机拥有一个表面看似与主机不同的IP，但是此IP是通过地址转换后得到的，实际上是与主机共享IP</strong>）。</p><h2 id="Host-Only-模式"><a href="#Host-Only-模式" class="headerlink" title="Host Only 模式"></a>Host Only 模式</h2><p>仅主机模式，是一种比NAT模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机系统之间提供网络连接。相对于NAT模式而言，仅主机模式不具备NAT功能，因此在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。</p><p>在同一台主机上可以创建多个仅主机模式的虚拟网络，如果多个虚拟机处于同一个仅主机模式网络中，那么它们之间是可以相互通信的；如果它们处于不同的仅主机模式网络，则默认情况下无法进行相互通信(可通过在它们之间设置路由器来实现相互通信)。</p><h2 id="关于三种模式的一段形象的比喻"><a href="#关于三种模式的一段形象的比喻" class="headerlink" title="关于三种模式的一段形象的比喻"></a>关于三种模式的一段形象的比喻</h2><p>（1）桥接模式的虚拟机，就像一个在路由器”民政局”那里”上过户口”的成年人，有自己单独的居住地址，虽然和主机住在同一个大院里，但好歹是有户口的人，可以大摇大摆地直接和外面通信。</p><p>（2）NAT模式的虚拟机，纯粹就是一个没上过户口的黑户，路由器”民政局”根本不知道有这么个人，自然也不会主动和它通信。即使虚拟机偶尔要向外面发送点的信件，都得交给主机以主机的名义转发出去，主机还专门请了一位叫做NAT的老大爷来专门负责这些虚拟机的发信、收信事宜。</p><p>（3）仅主机模式的虚拟机，纯粹是一个彻彻底底的黑奴，不仅没有户口、路由器”民政局”不知道这么号人，还被主机关在小黑屋里，连信件也不准往外发。</p><p>其中这个仅主机模式能够保障我们在拔掉网线的情况下继续连接我们的虚拟机，不依靠公网连接，而是依靠物理机和虚拟机的关系连接。在断网的情况下，利用这个模式，我们可以继续连接虚拟机，实现我们的操作。</p><h1 id="无法联网问题的解决方法"><a href="#无法联网问题的解决方法" class="headerlink" title="无法联网问题的解决方法"></a>无法联网问题的解决方法</h1><p>我相信很多小伙伴也从各种博客中取了不少经，根据不同的网络连接模式来采用不同的方法。而我使用的方法很暴力，相当于恢复出场设置。</p><p><strong>第一步：关闭虚拟机———编辑———虚拟网络编辑器</strong><br><img src="https://img-blog.csdnimg.cn/20190330143720525.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70"><br><strong>第二步：点击图中红框中的更改设置</strong><br><img src="https://img-blog.csdnimg.cn/20190330143829864.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70"></p><p><strong>第三步：分别对VMnet0、VMnet1、VMnet8 进行 还原默认设置，每一项的还原默认设置都需要等待一会</strong></p><p><img src="https://img-blog.csdnimg.cn/20190330143951716.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE4OTY1,size_16,color_FFFFFF,t_70"><br><strong>第四步：点击确定，并且重开虚拟机，就会发现问题解决啦！</strong></p>]]></content>
    
    
    <categories>
      
      <category>实战问题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
